# -*- coding: utf-8 -*-
"""com_gto_comparacion_mod.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gU-T6x9uXvVycn3SLD04L8CWsH0WI8L9
"""


from numpy import arange,array,dot,asarray,zeros,apply_along_axis,around,sort,shape,savetxt,array_equal,max,argmin,argmax,fill_diagonal,diag,argsort,unique
from numpy.linalg import eig
from matplotlib.pyplot import plot,figure,title,legend,xlabel,ylabel,grid,axhline,axvline,savefig,imshow,show,scatter,hist,bar,subplots,Normalize,cm
from math import sqrt
import pandas as pd
from datetime import datetime,timedelta
from sklearn.cluster import AgglomerativeClustering,KMeans,SpectralClustering
import matplotlib.patches as mpatches
import geopandas
import networkx as nx
import leidenalg as la
import igraph as ig
import pycombo
pd.options.display.max_rows=10
from ProposedAlgorithms import count_month,GeNA,ReVAM,print_com,transf,com_to_group,change,generate_patches,modularity,col_map_level,transf_cases_gto

"""List of colors to use in maps"""

colors = ['red','green','hotpink','blue','purple','yellow','cyan','magenta','brown','olive','darkorange','gold']

"""#Importar datos para crear mapas"""

mun_gto_map = geopandas.read_file('mgm_gto2020.shp')
mun_gto_map.head()

"""#Import the epidemiological data"""

df = pd.read_csv('Casos_Municipio_20220515.csv')
#Delete records with null value
df = df.dropna()
print("Database size:")
print(df.shape)
print("Data Overview:")
print(df.info())
#How many different values ​​each variable has
print("Number of different values ​​for each variable:")
print(df.nunique())
#Check for null values
print("Null values ​​in each variable")
print(df.isnull().sum())
#Apply filter to only obtain municipalities of Guanajuato
#Guanajuato is the 11th state
df1 = df[df['cve_ent']>=11000]
df2 = df1[df1['cve_ent']<12000]
df_ord = df2.sort_values('cve_ent')
#Save labels of the names of municipalities
name_mun = df_ord["nombre"].tolist()
#Delete columns that do not correspond to daily cases registered
df_ord.drop(['cve_ent','poblacion','nombre'], axis = 1, inplace = True)
#Pass dataframe values ​​to an array
data = df_ord.values
#The first record corresponds to February 26, 2020
#The last record corresponds to May 14, 2022
n,m = shape(data)
#Define list with indices that are beginning of each month
month_name = ['mar20','apr20','may20','jun20','jul20','aug20','sep20','oct20','nov20','dec20','jan21','feb21','mar21','apr21','may21',
          'jun21','jul21','aug21','sep21','oct21','nov21','dec21','jan22','feb22','mar22','apr22','may22']
month_ini = [4,35,65,97,127,158,189,219,250,280,311,342,370,401,431,462,492,523,554,584,615,645,676,707,735,766,796]

#Import the names of the municipalities in the format necessary for the map
df_etiq = pd.read_excel("municipios_gto.xlsx", sheet_name = "Hoja1")
#Import population of each municipality of Guanajuato
population = df_etiq["Poblacion"]



"""#Apply Generalized Newman Algorithm

Get adjacency matrix and weight matrix
"""
#Import adjacency matrix from Excel
df1 = pd.read_excel("mat_adj_gto.xlsx", sheet_name="Sheet1")
mat_adj = df1.values

#Cases counted for each month registered
mat_count_month = count_month(month_ini,data)

#Determination of the weight matrix from June 2021 to February 2022
cases_per = zeros((46))
#There are 9 months that will need to be added for the period considered
for k in range(0,9):
  mes_act=mat_count_month[:,k+15]
  cases_per = cases_per+mes_act

#Construct the weight matrix using the adjacency matrix
W_jun_feb = zeros((46,46))
for i in range(0,46):
    for j in range(i+1,46):
        if mat_adj[i,j+1]==1:
            W_jun_feb[i,j] = (cases_per[i]+cases_per[j])/18
            W_jun_feb[j,i] = (cases_per[i]+cases_per[j])/18



"""#Apply Leiden algorithm using CPM as partition type for optimization"""

#Creation of the weighted igraph type graph based on W
def create_graph_W_ig(W):
    #Matrix size W
    n = len(W)
    #Initialize the edge list
    list_edges = []
    #Initialize weight list
    list_weigths = []
    for i in range(0,n):
        for j in range(i+1,n):
              if W[i,j]>0:
                  list_edges.append((i,j))
                  list_weigths.append(W[i,j])
    g = ig.Graph(edges = list_edges, directed = False)
    return g,list_weigths

"""Change the resolution parameter to obtain partitions with a number of communities between 2 and 15"""

g_ig,g_weigths = create_graph_W_ig(W_jun_feb)
#gamma is the resolution parameter
#Up to 15 communities
val_res_leid_cpm = arange(0.25,48.25,0.25)
#Array that will contain the number of communities obtained with each resolution value
num_com_k_leid_cpm = zeros((len(val_res_leid_cpm)))
#List of partitions that are generated with each k
part_k_leid_cpm = []
#Modularity of each partition
mod_k_leid_cpm = zeros((len(val_res_leid_cpm)))
#Counter
count = 0
for gamma in val_res_leid_cpm:
    #Partition obtained with current resolution value
    com_leiden_gamma = list(la.find_partition(g_ig, la.CPMVertexPartition, weights=g_weigths, resolution_parameter = gamma, seed = 15))
    #Number of communities in the partition
    num_com_gamma = len(com_leiden_gamma)
    num_com_k_leid_cpm[count] = num_com_gamma
    #Partition modularity
    mod_k_leid_cpm[count] = modularity(W_jun_feb,com_leiden_gamma)
    count += 1

#Sort lists according to the number of communities in the k-th partition
val_res_leid_sort = [x for _,x in sorted(zip(num_com_k_leid_cpm,val_res_leid_cpm))]
mod_k_leid_sort = [x for _,x in sorted(zip(num_com_k_leid_cpm,mod_k_leid_cpm))]
num_com_leid_sort = sorted(num_com_k_leid_cpm)
#Determine the positions where the jump in increasing the number of communities is obtained in the ordered lists
jump_leid_cpm = []
com_act = 1
for i in range(0,len(num_com_leid_sort)):
    #Current number of communities
    num_com_act = num_com_leid_sort[i]
    if num_com_act > com_act:
        jump_leid_cpm.append(i)
        com_act = num_com_act
'''
print("Resolution parameter values:")
print(val_res_leid_sort)
print("Number of communities obtained with the resolution parameter:")
print(num_com_leid_sort)
print("Partition modularity:")
print(mod_k_leid_sort)
print(jump_leid_cpm)
'''

"""Obtain the maximum modularity found for each number of communities"""

max_mod_leid_cpm = []
arg_max_mod_leid_cpm = []
for i in range(0,len(jump_leid_cpm)-1):
    max_mod_leid_cpm.append(max(mod_k_leid_sort[jump_leid_cpm[i]:jump_leid_cpm[i+1]]))
    arg_max_mod_leid_cpm.append(argmax(mod_k_leid_sort[jump_leid_cpm[i]:jump_leid_cpm[i+1]]))
print("Maximum modularity obtained for each number of communities from 2 to 15:")
print(max_mod_leid_cpm)
print("Maximum modularity among all partitions:")
print(max(max_mod_leid_cpm))

"""Partition with maximum modularity (gamma=29.5)"""

argmax_mod_leid_cpm = argmax(max_mod_leid_cpm)
gamma_max_leiden = val_res_leid_sort[jump_leid_cpm[argmax_mod_leid_cpm]+arg_max_mod_leid_cpm[argmax_mod_leid_cpm]]
com_leiden_gamma_max = list(la.find_partition(g_ig, la.CPMVertexPartition, weights=g_weigths, resolution_parameter = gamma_max_leiden, seed = 15))
print_com(W_jun_feb,com_leiden_gamma_max,name_mun)

"""Color the map corresponding to this partition"""

com_leiden_max_new = transf(com_leiden_gamma_max)
groups_leiden_max = com_to_group(com_leiden_max_new)
colors_leiden_max = change(groups_leiden_max, colors[0:len(com_leiden_max_new)])
#Color map
fig,ax = subplots(figsize = (12,8))
#Assign community labels to colors
color_patches = generate_patches(colors[0:len(com_leiden_max_new)])
ax.legend(handles = color_patches, prop = {'size':12}, loc = 4)
ax.set_title('Best partiton obtained with Leiden CPM is not good',fontdict = {'fontsize': '14', 'fontweight': '3'})
ax.axis('off')
mun_gto_map.plot(color = colors_leiden_max, ax = ax)


"""#Apply Leiden algorithm using RBConfigurationVertexPartition as partition type for optimization

Change the resolution parameter to obtain partitions with a number of communities between 2 and 23
"""

#gamma is the resolution parameter
#Up to 23 communities
val_res_leid_rbc = arange(0.1,9.282,0.002)
#Array that will contain the number of communities obtained with each resolution value
num_com_k_leid_rbc = zeros((len(val_res_leid_rbc)))
#List of partitions that are generated with each k
part_k_leid_rbc = []
#Modularity of each partition
mod_k_leid_rbc = zeros((len(val_res_leid_rbc)))
#Counter
count = 0
for gamma in val_res_leid_rbc:
    #Partition obtained with current resolution value
    com_leid_gamma = list(la.find_partition(g_ig, la.RBConfigurationVertexPartition, weights=g_weigths, resolution_parameter = gamma, seed = 15))
    #Number of communities in the partition
    num_com_gamma = len(com_leid_gamma)
    num_com_k_leid_rbc[count] = num_com_gamma
    #Partition modularity
    mod_k_leid_rbc[count] = modularity(W_jun_feb,com_leid_gamma)
    count += 1

#Sort lists according to the number of communities in the k-th partition
val_res_leid_sort = [x for _,x in sorted(zip(num_com_k_leid_rbc,val_res_leid_rbc))]
mod_k_leid_sort = [x for _,x in sorted(zip(num_com_k_leid_rbc,mod_k_leid_rbc))]
num_com_leid_sort = sorted(num_com_k_leid_rbc)
#Determine the positions where the jump in increasing the number of communities is obtained in the ordered lists
jump_leid_rbc = []
com_act = 1
for i in range(0,len(num_com_leid_sort)):
    #Current number of communities
    num_com_act = num_com_leid_sort[i]
    if num_com_act > com_act:
        jump_leid_rbc.append(i)
        com_act = num_com_act
'''
print("Resolution parameter values:")
print(val_res_leid_sort)
print("Number of communities obtained with the resolution parameter:")
print(num_com_leid_sort)
print("Partition modularity:")
print(mod_k_leid_sort)
print(jump_leid_rbc)
'''

"""Obtain the maximum modularity found for each number of communities"""

max_mod_leid_rbc = []
arg_max_mod_leid_rbc = []
for i in range(0,len(jump_leid_rbc)-1):
    max_mod_leid_rbc.append(max(mod_k_leid_sort[jump_leid_rbc[i]:jump_leid_rbc[i+1]]))
    arg_max_mod_leid_rbc.append(argmax(mod_k_leid_sort[jump_leid_rbc[i]:jump_leid_rbc[i+1]]))
print("Maximum modularity obtained for each number of communities from 2 to 23:")
print(max_mod_leid_rbc)
print("Maximum modularity among all partitions:")
print(max(max_mod_leid_rbc))

"""Partition with maximum modularity (gamma=0.824)"""

argmax_mod_leid_rbc = argmax(max_mod_leid_rbc)
gamma_max_leid_rbc = val_res_leid_sort[jump_leid_rbc[argmax_mod_leid_rbc]+arg_max_mod_leid_rbc[argmax_mod_leid_rbc]]
com_leiden_gamma_max = list(la.find_partition(g_ig, la.RBConfigurationVertexPartition, weights=g_weigths, resolution_parameter = gamma_max_leid_rbc, seed = 15))
print_com(W_jun_feb,com_leiden_gamma_max,name_mun)

"""Color the corresponding map"""

com_leid_max_new = transf(com_leiden_gamma_max)
groups_leid_max = com_to_group(com_leid_max_new)
colors_leid_max = change(groups_leid_max, colors[0:len(com_leid_max_new)])
#Color map
#Create figure and axes for Matplotlib
fig,axs = subplots(3, 2, figsize = (27,22))
ax0 = axs[0,0]
#Assign community labels to colors
color_patches = generate_patches(colors[0:len(com_leid_max_new)])
ax0.legend(handles = color_patches, prop = {'size':7}, loc = 4)
ax0.axis('off')
ax0.set_title('(a) Leiden RBC', fontdict = {'fontsize': '11', 'fontweight': '3'})
mun_gto_map.plot(color = colors_leid_max, ax = ax0)


"""#Compare with spectral clustering QR algorithm"""

def sep_com(labels,n_clust):
    com_sep = []
    for k in range(0,n_clust):
        com_sep.append([])
    n = len(labels)
    for i in range(0,n):
        com_act = com_sep[labels[i]]
        com_act.append(i)
    return com_sep

"""Implementation from sklearn"""

#List to store modularity of each partition
mod_spec_clust = []
for i in range(2,24):
    clustering = SpectralClustering(n_clusters=i, affinity='precomputed', assign_labels='cluster_qr', random_state=0).fit(W_jun_feb)
    com_act = sep_com(clustering.labels_,i)
    mod = modularity(W_jun_feb,com_act)
    mod_spec_clust.append(mod)

"""
Partition that maximized modularity
"""
print("Partition using QR spectral clustering considering 6 communities:")
part_spec_max = SpectralClustering(n_clusters=6, affinity='precomputed', assign_labels='cluster_qr', random_state=0).fit(W_jun_feb)
part_spec_max_list = sep_com(part_spec_max.labels_,6)
print_com(W_jun_feb,part_spec_max_list,name_mun)

com_6_new = transf(part_spec_max_list)
groups_6 = com_to_group(com_6_new)
colors_6 = change(groups_6,colors[0:len(com_6_new)])
#Color mapa
#Create figure and axes for Matplotlib
ax1 = axs[0,1]
#Assign community labels to colors
color_patches = generate_patches(colors[0:len(com_6_new)])
ax1.legend(handles =  color_patches, prop = {'size':7}, loc = 4)
ax1.axis('off')
ax1.set_title('(b) Spectral clustering QR', fontdict = {'fontsize': '11', 'fontweight': '3'})
mun_gto_map.plot(color = colors_6, ax = ax1)


"""#Compare with Louvain algorithm"""

#Creation of the weighted Networkx type graph based on W
def create_graph_W_nx(W):
    G = nx.Graph()
    #Matrix size W
    n = len(W)
    #Initialize the list of weighted edges
    list_weighted_edges = []
    for i in range(0,n):
        for j in range(i+1,n):
              if W[i,j]>0:
                  list_weighted_edges.append((i,j,W[i,j]))
    G.add_weighted_edges_from(list_weighted_edges)
    return G

#Function to transform list of sets into list of lists
def set_to_list(list_old):
      #Number of items in the list
      n = len(list_old)
      #Initialize new list
      list_new = []
      for i in range(0,n):
            list_new.append(list(list_old[i]))
      return list_new

#Creacion del grafo asociado a la matriz de pesos W_jun_feb
G_nx = create_graph_W_nx(W_jun_feb)

"""Change the resolution parameter to obtain partitions with a number of communities between 2 and 23"""

#gamma is the resolution parameter
#Up to 23 communities
val_res_louv = arange(0.15,9.525,0.025)
#Array that will contain the number of communities obtained with each resolution value
num_com_k_louv = zeros((len(val_res_louv)))
#List of partitions that are generated with each k
part_k_louv = []
#Modularity of each partition
mod_k_louv = zeros((len(val_res_louv)))
#Counter
count = 0
for gamma in val_res_louv:
    #Partition obtained with current resolution value
    com_louv_gamma = nx.community.louvain_communities(G_nx, weight='weight', resolution=gamma, threshold=1e-07, seed=13)
    #Number of communities in the partition
    num_com_gamma = len(com_louv_gamma)
    num_com_k_louv[count] = num_com_gamma
    #Partition Modularity
    mod_k_louv[count] = nx.community.modularity(G_nx, com_louv_gamma)
    count += 1

#Sort lists according to the number of communities in the k-th partition
val_res_louv_sort = [x for _,x in sorted(zip(num_com_k_louv,val_res_louv))]
mod_k_louv_sort = [x for _,x in sorted(zip(num_com_k_louv,mod_k_louv))]
num_com_louv_sort = sorted(num_com_k_louv)
#Determine the positions where the jump in increasing the number of communities is obtained in the ordered lists
jump_louv = []
com_act = 1
for i in range(0,len(num_com_louv_sort)):
    #Current number of communities
    num_com_act = num_com_louv_sort[i]
    if num_com_act > com_act:
        jump_louv.append(i)
        com_act = num_com_act
'''
print("Resolution parameter values:")
print(val_res_louv_sort)
print("Number of communities obtained with the resolution parameter:")
print(num_com_louv_sort)
print("Partition modularity:")
print(mod_k_louv_sort)
print(jump_louv)
'''

"""Obtain the maximum modularity found for each number of communities"""

max_mod_louv = []
arg_max_mod_louv = []
for i in range(0,len(jump_louv)-1):
    max_mod_louv.append(max(mod_k_louv_sort[jump_louv[i]:jump_louv[i+1]]))
    arg_max_mod_louv.append(argmax(mod_k_louv[jump_louv[i]:jump_louv[i+1]]))
print("Maximum modularity obtained for each number of communities from 2 to 23:")
print(max_mod_louv)
print("Maximum modularity among all partitions:")
print(max(max_mod_louv))

"""Partition with maximum modularity (gamma=1.0499999999999998)"""

argmax_mod_louv = argmax(max_mod_louv)
gamma_max_louv = val_res_louv_sort[jump_louv[argmax_mod_louv]+arg_max_mod_louv[argmax_mod_louv]]
com_louv_gamma_max = nx.community.louvain_communities(G_nx, weight='weight', resolution=gamma_max_louv, threshold=1e-07, seed=13)
#Convert result to list of lists
com_louv_max = set_to_list(com_louv_gamma_max)
print_com(W_jun_feb,com_louv_max,name_mun)

"""Color the map corresponding to this partition"""

com_louv_max_new = transf(com_louv_max)
groups_louv_max = com_to_group(com_louv_max_new)
colors_louv_max = change(groups_louv_max, colors[0:len(com_louv_max_new)])
#Color mapa
#Create figure and axes for Matplotlib
ax2 = axs[1,0]
#Assign community labels to colors
color_patches = generate_patches(colors[0:len(com_louv_max_new)])
ax2.legend(handles = color_patches, prop = {'size':7}, loc = 4)
ax2.axis('off')
ax2.set_title('(c) Louvain', fontdict = {'fontsize': '11', 'fontweight': '3'})
mun_gto_map.plot(color = colors_louv_max, ax = ax2)


"""#Apply Combo Algorithm"""
#gamma is the resolution parameter
#Up to 23 communitie
val_res_combo = arange(0.01,9.81,0.01)
#Array that will contain the number of communities obtained with each resolution value
num_com_k_combo = zeros((len(val_res_combo)))
#List of partitions that are generated with each k
part_k_combo = []
#Modularity of each partition
mod_k_combo = zeros((len(val_res_combo)))
#Counter
count = 0
for gamma in val_res_combo:
    part_combo_gamma = pycombo.execute(G_nx, weight = 'weight', modularity_resolution = gamma, random_seed=14)[0]
    sort_part_combo_gamma = dict(sorted(part_combo_gamma.items()))
    #Extract labels of the community assigned for each node
    keys_com = list(sort_part_combo_gamma.values())
    #Separate labels by communities to convert them into a list of lists
    part_list = sep_com(keys_com,max(keys_com)+1)
    #Number of communities of the paritition
    num_com_gamma = len(part_list)
    num_com_k_combo[count] = num_com_gamma
    #Modularity of the partition
    mod_k_combo[count] = modularity(W_jun_feb,part_list)
    count += 1

#Sort lists according to the number of communities in the k-th partition
val_res_combo_sort = [x for _,x in sorted(zip(num_com_k_combo,val_res_combo))]
mod_k_combo_sort = [x for _,x in sorted(zip(num_com_k_combo,mod_k_combo))]
num_com_combo_sort = sorted(num_com_k_combo)
#Determine the positions where the jump in increasing the number of communities is obtained in the ordered lists
jump_combo = []
com_act = 1
for i in range(0,len(num_com_combo_sort)):
    #Current number of communities
    num_com_act = num_com_combo_sort[i]
    if num_com_act > com_act:
        jump_combo.append(i)
        com_act = num_com_act
'''
print("Resolution parameter values:")
print(val_res_combo_sort)
print("Number of communities obtained with the resolution parameter:")
print(num_com_combo_sort)
print("Partition modularity:")
print(mod_k_combo_sort)
print(jump_combo)
'''
"""Obtain the maximum modularity found for each number of communities"""
max_mod_combo = []
arg_max_mod_combo = []
for i in range(0,len(jump_combo)-1):
    max_mod_combo.append(max(mod_k_combo_sort[jump_combo[i]:jump_combo[i+1]]))
    arg_max_mod_combo.append(argmax(mod_k_combo_sort[jump_combo[i]:jump_combo[i+1]]))
print("Maximum modularity obtained for each number of communities from 2 to 23:")
print(max_mod_combo)
print("Maximum modularity among all partitions:")
print(max(max_mod_combo))

"""Partition with maximum modularity"""
argmax_mod_combo = argmax(max_mod_combo)
gamma_max_combo = val_res_combo_sort[jump_combo[argmax_mod_combo]+arg_max_mod_combo[argmax_mod_combo]]
part_combo_max = pycombo.execute(G_nx, weight = 'weight', modularity_resolution = gamma_max_combo, random_seed=14)[0]
sort_part_combo_max = dict(sorted(part_combo_max.items()))
#Extract labels of the community assigned for each node
keys_com = list(sort_part_combo_max.values())
#Separate labels by communities to convert them into a list of lists
part_list_max = sep_com(keys_com,max(keys_com)+1)
print_com(W_jun_feb,part_list_max,name_mun)

"""Color the map corresponding to this partition"""
part_combo_max_new = transf(part_list_max)
groups_combo_max = com_to_group(part_combo_max_new)
colors_combo_max = change(groups_combo_max, colors[0:len(part_combo_max_new)])
#Color map
#Create figure and axes for Matplotlib
ax3 = axs[1,1]
#Remove the axis
ax3.axis('off')
ax3.set_title('(d) Combo', fontdict = {'fontsize': '11', 'fontweight': '3'})
#Assign community labels to colors
color_patches = generate_patches(colors[0:len(part_combo_max_new)])
ax3.legend(handles = color_patches, prop = {'size':7}, loc = 4)
ax3.axis('off')
mun_gto_map.plot(color = colors_combo_max, ax = ax3)



"""#Apply Resolution Variation Algorithm by Modularity (ReVAM)"""

#List to store partition modularity
mod_ReVAM = []
for i in range(2,24):
    part_act = ReVAM(W_jun_feb,i)
    new_com = []
    mod = modularity(W_jun_feb,part_act)
    mod_ReVAM.append(mod)
print(mod_ReVAM)

#Partition that maximized the modularity (4 communities)
part_max_ReVAM = ReVAM(W_jun_feb,4)
print("Partition into 4 communities using ReVAM:")
print_com(W_jun_feb,part_max_ReVAM,name_mun)
print()

"""Color map using geopandas"""

part_ReVAM_new = transf(part_max_ReVAM)
groups_ReVAM = com_to_group(part_ReVAM_new)
colors_ReVAM_max = change(groups_ReVAM, colors[0:len(part_ReVAM_new)])
#Color map
#Create figure and axes for Matplotlib
ax4 = axs[2,0]
#Remove the axis
ax4.axis('off')
ax4.set_title('(e) ReVAM (Proposed Algorithm)', fontdict = {'fontsize': '11', 'fontweight': '3'})
#Assign community labels to colors
color_patches = generate_patches(colors[0:len(part_ReVAM_new)])
ax4.legend(handles = color_patches, prop = {'size':7}, loc = 4)
mun_gto_map.plot(color = colors_ReVAM_max, ax = ax4)



"""#SICOM Zoning of the State of Guanajuato"""

#Import the names of the municipalities in the format necessary for the map
df_highway = pd.read_excel("highway_data.xlsx", sheet_name = "Hoja1")
zone_num = df_highway['Zone']
df_highway.info()

"""Color map with geopandas"""

#Divide the municipalities according to the four SICOM zones
zones = [[],[],[],[]]
n_mun = len(zone_num)
for i in range(0,n_mun):
    zones[zone_num[i]-1].append(i)

#Generate the four patches of the SICOM zones
def generate_zones_patches(colors):
    zone_label = ['NW','NE','SE','SW']
    list_patches = []
    n_colors=len(colors)
    for i in range(0,n_colors):
        patch_act = mpatches.Patch(color=colors[i], label=zone_label[i])
        list_patches.append(patch_act)
    return list_patches

zones_new = transf(zones)
groups_zones = com_to_group(zones_new)
colors_zones = change(groups_zones,colors[0:len(zones)])
#Color map
ax_zones = axs[2,1]
#Remove the axis
ax_zones.axis('off')
#Assign community labels to colors
color_patches = generate_zones_patches(colors[0:len(zones)])
ax_zones.legend(handles = color_patches,prop = {'size':7}, loc=4)
ax_zones.set_title('(f) Zones of Guanajuato Highway Network', fontdict = {'fontsize': '11', 'fontweight': '3'})
mun_gto_map.plot(color = colors_zones,ax = ax_zones)


"""Export image with a resolution of 600 dpi"""
fig.savefig("comparison_partitions_algorithms.png", dpi = 600)




"""#Compare the modularity obtained with the four methods by finding partitions with a number of communities between 2 and 23"""
fig = figure(figsize=(10,7))
t  = arange(2,24,1)
plot(t, max_mod_louv, linestyle="--", marker="s", markersize=8, linewidth=1.0, color='darkgreen', label='Louvain')
plot(t, max_mod_leid_rbc, linestyle="--", marker="h", markersize=8, linewidth=1.0, color='red', label='Leiden RBC')
plot(t, max_mod_combo, linestyle="--", marker="*", markersize=8, linewidth=1.0, color='black', label='Combo')
plot(t ,mod_spec_clust, linestyle="--", marker="<", markersize=8, linewidth=1.0, color='purple', label='Spectral Clustering QR')
plot(t, mod_ReVAM, linestyle="--", marker="o", markersize=8, linewidth=1.0, color='blue', label='ReVAM (Proposed Algorithm)')
ylabel("Modularity")
xlabel("Number of communities")
#title("Quality of partitions with different number of communities")
legend()
grid()


"""Export image with a resolution of 600 dpi"""
fig.savefig("comp_mod_res_alg.png",dpi=600)